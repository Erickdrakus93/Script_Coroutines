%! Author = erick-hdz
%! Date = 15/05/20

% Preamble
\documentclass[10pt a4paper]{report}


% Packages
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{algorithm, algorithmic}
\usepackage{amsfonts}
\usepackage{amsbsy}
\usepackage{makeidx}
\usepackage{geometry}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{natbib}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{latexsymb}

%Status of the document
\newtheorem*{corrollary}{Corrollary}
\newtheorem*{remark}{Remark}
\newtheorem*{definition}{Definition}
\newtheorem*{theorem}{Theorem}
\pagestyle{fancy}
\fancyhf{}
\rhead{Sección de tesis}
\lhead{Simulación de modelos}
\rfoot{Page\thepage}
\author{Erick Hernandez Navarrete}
\title{Simulacion de modelos}


% Document
\begin{document}
    \maketitle
    \chapter{Decibilidad en los modelos}\label{ch:decibilidad-en-los-modelos}
    \section{Introducción}\label{sec:introducción}
    En este documento expondremos las nociones de decibilidad
    en el mundo de maquinas de Turing y en el mundo distribuido,
    asi como formalizaremos la nocion de simulacion de modelos
    computacionales,demostrando que el modelo A de la maquina de
    Turing es equivalente en poder al modelo distribuido.

    \subsection{Decibilidad en el modelo de maquinas de Turing}\label{subsec:decibilidad-en-el-modelo-de-maquinas-de-turing}
    Primero enunciaremos los elementos del modelo de maquina de Turing,
    \theoremsyle{Definición}
    \begin{definition}
        Una maquina de Turing is una 7-tupla, $Q,\sigma,\lambda,\delta,q_{0},q_{accept},q_{reject})$
        donde $Q,\sigma,\lambda$ son conjuntos finitos.
        \begin{enumerate}
            \item $Q$ es el conjunto de estados,
            \item $\sigma$ es el alfabeto de entrada que no contiene el simbolo blanco $\sqcup$
            \item $\lambda$ es la cinta del alfabeto, donde  $\sqcup\in\lambda$ y ademas $\sigma\in\lambda$,
            \item $\delta: Q\times\lambda \rightarrow Q\times\lambda\times\{L,R,S\}$ es la funcion de transición.
            \item $q_{0}$ es el estado de iniciación,
            \item $q_{accept}$ es el estado de aceptacion
            \item $q_{reject}$ es el estado de rechazo,donde $q_{accept} \neq q_{reject}$,

        \end{enumerate}

    \end{definition}
    Esta definición esta encapsulando los elementos del modelo,
    asi que una vez que tenemos los elementos, podremos definir la semantica
    de que un problema se soluble en este clasico modelo,definiendo
    la noción de decidibilidad.
    \space
    Podemos observar que este modelo,las estructuras de dato que estan consumiendo
    son cadenas finitas,entonces una vez que le damos como entrada a una maquina de
    Turing una cadena $w$, podemos decir que esa cadena es aceptada o rechazada,
    entonces definimos lo siguiente:
    \theoremstyle{Definición}
    \begin{definition}
        Decimos que una maquina de Turing acepta una entrada $w$ si existe una secuencia de configuraciones
        $C_{1},\mathellipsis C_{n}$ tal que:
        \begin{enumerate}
            \item $C_{1}$ es la configuración inicial
            \item Cada $C_{i}$ le sigue $C_{i+1}$ y
            \item $C_{k}$ es el estado de aceptación

        \end{enumerate}
    \end{definition}

    \theoremstyle
    \theoremstyle{Definición}
    \begin{definition}
        Sea M una maquina de Turing.
        La colección de cadenas tales que $M$ las acepta,
        es un lenguaje decidible por $M$, y lo denotamos
        de la siguiente manera: $L(M)$.
    \end
    \subsection{Decibilidad en el modelo de computo distribuido  \textbf{LOCAL}}\label{subsec:decibilidad-en-el-modelo-de-computo-distribuido-local}
    Ahora lo que haremos es definir el modelo de computo distribuido de manera formal,
    y tomar un modelo en particular en la que enfocaremos nuestro estudio, para posteriormente
    estudiar la noción de decibilidad en dicho modelo.
    \subsection{Presentación del modelo de computo Distrubuido}\label{subsec:presentación-del-modelo-de-computo-distrubuido}
    \subsubsection{Prsentacion del protocolo de Comunicacion}

    Este modelo tendra una capa de abstracción de comunicacion, asi como su respectiva capa de
    computación de la siguiente manera.
    \subsubsection{Capa de comunicacion}
    El modelo de comunicación consiste en un protocolo uno a uno en la red que sera descrita por
    una grafica conexa, no dirigida $G=(V,E)$, donde los vertices $V=\{ v_{1},\mathellipsis v_{n}\}$
    representan a los procesos de la red y los aristas representan los canales de comunicación bidireccionales
    operando entre ellos.
    Inicialmente consiraremos identificadores unicos asignados a los procesos de la grafica $G$,
    Mas concretamente consideraremos a estos identifiadores de un conjunto ordenado de enteros:
    de la siguiente manera:
    \begin{equation}
        S = \{ s_{1},\mathellipsis,s_{n}\}
        donde: s_{i} < s_{i+1} \forall i\leq 1
    \end{equation}
    Entonces con esta notacion, una ID-asignación es un mapeo:
    $ID:V\rightarrow S$ entonce nos referiremos a su identificador como:
    $ID(v)$
    Entonces la comunicación se llevara acabo de la siguiente manera:
    Cada vertice tendra asociado el numero de puertos como el $deg_{G}(v)$,
    entonces en este sentido el conjunto de aristas adjacentes al vertice
    contiene exactamente $deg_{G}(v)$,donde cada arista esta conectado en un puerto de v.
    \space
    Podemos denotar que a cada arista $(u,v)$ le corresponde la pareja
    $((u,i),(v,j))$ donde $1\leq i \leq deg_{G}(u) $ y $1\leq j \leq deg_{G}(v)$
    que le da la semantica de que el canal esta conectado en el canal $i$ del proceso $u$
    con el puerto $j$ del proceso $v$.
    \subsubsection{Capa de Computacion}
    Una vez que tenemos la capa de comunicacion,presentaremos la capa formal del modelo de
    computo.
    El modelo estara governado por un algoritmo $\pi$ que estara compuesto de protocolos
    $\pi_{1},\mathellipsis,\pi_{n}$ donde cada $\pi_{i}$ residira en el proceso
    $p_{i}$.
    \theoremstyle
    \begin{remark}
        Podemos observar que podemos modelar a cada $p_{i}$ como una maquina de estado con su
        correspodiente estado $Q_{i}$ conteniendo su estado inicial  $q_{0i}$ tal que en un
        momento dado el proceso $p_{i}$ esta en el estado $q_{i}$ de $Q_{i}$.
    \end{remark}
    Por otro lado en el lado de la capa de comunicacion tendremos el siguiente esquema:
    En cualquier momento dado y en cualquier canal de comunicación $e_{i}=(u,v)$ esta en algun estado
    $\overline{q_{i}}$ del conjunto de estados $Q_{i}$
    el estado $\overline{q_{i}}$ esta compuesto de dos componentes denotadas de la siguiente manera:
    $\overline{q_{u\leftarrow v}}$ y $\overline{q_{v\leftarrow v}}$ una por cada direccion del canal
    de comunicación.
    Vamos a denotar de la






\end{document}