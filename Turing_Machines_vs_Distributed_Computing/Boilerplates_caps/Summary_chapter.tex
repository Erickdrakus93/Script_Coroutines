%! Author = erick-hdz
%! Date = 15/05/20

% Preamble
\documentclass[10pt]{report}


% Packages
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{algorithm, algorithmic}
\usepackage{amsfonts}
\usepackage{amsbsy}
\usepackage{makeidx}
\usepackage{geometry}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{natbib}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{lastpage}
\usepackage{BibLaTeX}

%Status of the document
\pagenumbering{roman}
\newtheorem{corrollary}{Corrollary}
\newtheorem*{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\pagestyle{fancy}
\fancyhf{}
\rhead{Sección de tesis}
\lhead{Simulación de modelos}
\rfoot{Page  \thepage}
\author{Erick Hernandez Navarrete}
\title{Simulación de modelos}


% Document
\begin{document}
    %todo:Correcciones del documento en forma de check speller.
    \maketitle
    \tableofcontents{}
    \chapter{Decidibilidad en los modelos}\label{ch:decidibilidad-en-los-modelos}
    \section{Introducción}\label{sec:introducción}
    En este documento expondremos las nociones de decibilidad
    en el mundo de maquinas de Turing y en el mundo distribuido,
    asi como formalizaremos la noción de simulación de modelos
    computacionales,demostrando que el modelo $A$ de  la maquina de
    Turing es equivalente en poder al modelo distribuido $B$ en particular al modelo \texttt{LOCAL}.

    \section{Decidibilidad en el modelo de maquinas de Turing}\label{sec:decidibilidasd-en-el-modelo-de-maquinas-de-turing}
    \subsection{Elementos del modelo}\label{subsec:elementos-del-modelo-de-maquina-de-turing}
    Primero enunciaremos los elementos del modelo de maquina de Turing,
    \begin{definition}
        Una maquina de Turing is una 7-tupla, $Q,\sigma,\lambda,\delta,q_{0},q_{accept},q_{reject})$
        donde $Q,\sigma,\lambda$ son conjuntos finitos.
        \begin{enumerate}
            \item $Q$ es el conjunto de estados,
            \item $\sigma$ es el alfabeto de entrada que no contiene el simbolo blanco $\sqcup$
            \item $\lambda$ es la cinta del alfabeto, donde  $\sqcup\in\lambda$ y ademas $\sigma\in\lambda$,
            \item $\delta: Q\times\lambda \rightarrow Q\times\lambda\times\{L,R,S\}$ es la funcion de transición.
            \item $q_{0}$ es el estado de iniciación,
            \item $q_{accept}$ es el estado de aceptacion
            \item $q_{reject}$ es el estado de rechazo,donde $q_{accept} \neq q_{reject}$,

        \end{enumerate}

    \end{definition}
    Esta definición esta encapsulando los elementos del modelo,
    asi que una vez que tenemos los elementos, podremos definir la semantica
    de que un problema se soluble en este clasico modelo,definiendo
    la noción de decidibilidad.
    \space
    \subsection{Decidibilidad}\label{subsec:decidibilidad2}
    Podemos observar que este modelo,las estructuras de dato que estan consumiendo
    son cadenas finitas(infinitas),entonces una vez que le damos como entrada a una maquina de
    Turing una cadena $w$, podemos decir que esa cadena es aceptada o rechazada,
    entonces definimos lo siguiente:
    \theoremstyle{definition}
    \begin{definition}
        Decimos que una maquina de Turing acepta una entrada $w$ si existe una secuencia de configuraciones
        $C_{1},\mathellipsis C_{n}$ tal que:
        \begin{enumerate}
            \item $C_{1}$ es la configuración inicial
            \item Cada $C_{i}$ le sigue $C_{i+1}$ y
            \item $C_{k}$ es la configuración de aceptación

        \end{enumerate}
    \end{definition}

    \theoremstyle{definition}
    \begin{definition}
        Sea M una maquina de Turing.
        La colección de cadenas tales que $M$ las acepta,
        es un lenguaje decidible por $M$, y lo denotamos
        de la siguiente manera: $L(M)$.
    \end{definition}
    \section{Decidibilidad en el modelo de computo distribuido  \textbf{LOCAL}}\label{sec:decidibilidad-en-el-modelo-de-computo-distribuidotextbf}
    Ahora lo que haremos es definir el modelo de computo distribuido de manera formal,
    y tomar un modelo en particular en la que enfocaremos nuestro estudio, para posteriormente
    estudiar la noción de decibilidad en dicho modelo.
    \subsection{Presentación del modelo de computo distribuido}\label{subsec:presentación-del-modelo-de-computo-distrubuido}
    \subsubsection{Presentación del protocolo de comunicación}

    Este modelo tendra una capa de abstracción de comunicacion, asi como su respectiva capa de
    computación de la siguiente manera.
    \subsubsection{Capa de comunicación}
    El modelo de comunicación consiste en un protocolo uno a uno en la red que sera descrita por
    una grafica conexa, no dirigida $G=(V,E)$, donde los vertices $V=\{ v_{1},\mathellipsis v_{n}\}$
    representan a los procesos de la red y los aristas representan los canales de comunicación bidireccionales
    operando entre ellos.
    Inicialmente consiraremos identificadores unicos asignados a los procesos de la grafica $G$,
    Mas concretamente consideraremos a estos identifiadores de un conjunto ordenado de enteros:
    de la siguiente manera:
    \begin{equation}
        S = \{ s_{1},\mathellipsis,s_{n}\} \
        donde:\ s_{i} < s_{i+1} \ \forall i\leq 1
    \end{equation}
    Entonces con esta notacion, una ID-asignación es un mapeo:
    $ID:V\rightarrow S$ entonce nos referiremos a su identificador como:
    $ID(v)$
    Entonces la comunicación se llevara acabo de la siguiente manera:
    Cada vertice tendra asociado el numero de puertos como el $deg_{G}(v)$,
    entonces en este sentido el conjunto de aristas adjacentes al vertice
    contiene exactamente $deg_{G}(v)$,donde cada arista esta conectado en un puerto de v.
    \space
    Podemos denotar que a cada arista $(u,v)$ le corresponde la pareja
    $((u,i),(v,j))$ donde $1\leq i \leq deg_{G}(u) $ y $1\leq j \leq deg_{G}(v)$
    que le da la semantica de que el canal esta conectado en el canal $i$ del proceso $u$
    con el puerto $j$ del proceso $v$.
    \subsubsection{Capa de Computacion}
    Una vez que tenemos la capa de comunicacion,presentaremos la capa formal del modelo de
    computo.
    El modelo estara governado por un algoritmo $\Pi$ que estara compuesto de protocolos
    $\Pi_{1},\mathellipsis,\Pi_{n}$ donde cada $\Pi_{i}$ residira en el proceso
    $p_{i}$.
    %!----Incluir las observaciones pertinentes---!%
    \begin{remark}
        Podemos observar que podemos modelar a cada $\Pi_{i}$ como una maquina de estado para $\forall i$ con su
        correspodiente conjunto de estados estado $Q_{i}$ conteniendo su estado inicial  $q_{0i}$ tal que en cualquier
        momento dado el proceso $p_{i}$ esta en el estado $q_{i}$ de $Q_{i}$.
    \end{remark}
    Por otro lado en el lado de la capa de comunicacion tendremos el siguiente esquema:
    En cualquier momento dado y en cualquier canal de comunicación $e_{i}=(u,v)$ esta en algun estado
    $\overline{q}_{i}$ del conjunto de estados $\overline{Q}_{i}$
    el estado $\overline{q}_{i}$ esta compuesto de dos componentes denotadas de la siguiente manera:
    $\overline{q}_{u\leftarrow v}$ y $\overline{q}_{v\leftarrow v}$ una por cada direccion del canal
    de comunicación.
    Vamos a denotar como $\Mu$ como la colleccion de todos los posibles mensajes que se pueden enviar
    que se pueden enviar de un proceso a otro en toda ejecucion del algoritmo,
    cada uno de los dos componentes $\overline{q}_{u \leftarrow v}$ es un elemento de $\Mu \cup \lambda$,
    $\overline{q}_{u\leftarrow v} = MSG\in \Mu$ significa que ahora el mensaje $MSG$ esta en transicion de
    $u$ a $v$, y denotaremos que $\overline{q}_{u\leftarrow v} = \lambda$ para representar el echo de que
    el canal actual esta vacio en esa dirección.
    En el inicio del computo, todos los procesos estan en el estado inicial $q_{0,i}$
    y todos los canales de comunicación estan vacios.
    Es decir que sintacticamente: $\overline{q}_{i,0}   = <\lambda,\lambda>$

    \subsubsection{Ejecución de un algorimo en este modelo}
    La ejecución del algoritmo en este ambiente consistira de \textbf{Eventos} ocurriendo en diversos
    lugares de la red y afectando a los procesos afectados.
    Los eventos puede ser del tipo:
    \begin{itemize}
        \item Computacional:representando un paso en un procesador
        \item Comunicación: representando la entrega o la recepción de un mensaje.
    \end{itemize}
    Donde cada evento de comunicación tiene una semantica de:
    $SEND(i,j,MSG)$ o $DELIVER(i,j,MSG)$ para algún $MSG\Mu$.
    Entonces a manera de reportorio de eventos tenemos:
    \begin{enumerate}
        \item Evento $COMPUTE(i)$:El proceso $v_{i}$ ejecuta una operación interna, basado en su estado local, y
        posiblemente cambie su estado local.
        \item Event $SEND(i,j,MSG)$:El proceso $v_{i}$ envia de salida un mensaje $MSG\in \Mu$ en algun canal de
        comunicacion link $e_{l}$ con destino al proceso $v_{j}$
        \item Event:$DELIVER(i,j,MSG)$: El mensaje $M\in \Mu$ originado de un proceso $v_{i}$
        que es enviado por el canal de comunicación $e_{l}$ es entregado en la entrada del destino $v_{j}$
    \end{enumerate}
    Entonces la computación en un sistema distribuido lo podemos pensar de la siguiente manera:
    Como una secuencia de configuraciones, capturando el estado actual de los procesos y los canales de comunicación,
    Cada evento cambia de estado para algun procesador $v_{i}$, y posiblemente también para un canal de comunicación
    y eso cambiara la configuracion del sistema.
    En terminos formales lo podemos pensar de la siguiente manera:
    \theoremstyle{definition}
    \begin{definition}
        Una configuracion es una tupla $(q_{1},\mathellipsis,q_{n},\overline{q}_{1},\mathellipsis,\overline{q}_{m})$
        donde $q_{i},\overline{q}_{j}$ es el estado del procesador $p_{i}$ y del canal de comunicación $e_{j}$ respectivamente
        y la configuración inicial es:
        \begin{equation}
        q_{0,1},\mathellipsis,q_{0,n},\overline{q}_{0,1},\mathellipsis \overline{q}_{0,m}
        \end{equation}
        Entonces modelaremos la computación del algoritmo como una (posible) infinita secuencia de configuraciones
        alternadamente con eventos.
    \end{definition}
    \theoremstyle{definition}
    \begin{definition}
        La ejecución de un algoritmo $\Pi$ en una grafica con cirta topologia
        $G$ con una entrada inicial $I$ en los procesos es denotado como $\kappa_{\Pi(G,I)}$.
        Formalmente, una \textbf{ejecución} es una secuencia de la forma:
        \begin{equation}
            \kappa = (C_{0},\rho_{1},C_{1},\rho_{2},C_{2},\mathellipsis)
        \end{equation}
        donde cada $C_{k}$ es una configuración y cada $\rho_{j}$ es un evento.
    \end{definition}
    $C_{0}$ es la configuración inicial y el mapeo $C_{k-1}, \rho_{k},C_{k}$ tiene una semantica natural,
    i.e por decir que $\rho_{k}$ es un evento de naturaleza computacional para un proceso $v_{i}$,llamado por
    el nombre del repertorio de eventos $COMPUTE(i)$ entonces el unico cambio en $C_{k}$ con respecto a $C_{k-1}$
    es en el estado de $v_{i}$ (es decir es un cambio local), mas concretamente, el estado de $v_{i}$ en $C_{k}$
    es el resultado de applicar la función de transición de $v_{i}$ al estado de transición al estado de $C_{k-1}$
    %Aqui es importante recalcar que esto es una traduccion del hecho de que estamos haciendo en los procesos
    %Una simulacion de maquinas de estado.
    De igual manera los eventos pueden ser de naturaleza en la capa de comunicación:
    i.e $\rho_{k}$ podriamos pensar que es $SEND(i,j,MSG)$ entonces los unicos cambios de la
    configuracion involucra a los estados de las partes que ese evento esta envuelto, es decir
    cambiara el estado del proceso $v_{i}$, del canal de comunicación $e_{l}$ que conecta con el proceso $v_{j}$
    (en particular el cambio del estaddo $v_{i}$ reflajara el cambio del estado $e_{l}$, $\overline{q}_{v_{i}\rightarrow v_{j}}$
    hara que cambie del estado $\lambda$ a $MSG$.
    Igualmente se pensamos que $\rho_{k}$ es el evento $DELIVER(i,j,MSG)$ enonces los cambios del estado de $v_{j}$ se
    reflejan el estado del canal de comunicación $e_{l}$ que conecta con el proceso $v_{i}$, que es actualizado reflejando
    el echo de que el el canal es vacio y nuevamente el proceso tiene una entrada en donde conecta con el canal de
    comunicación $e_{l}$ que es a saber el mensaje $MSG$.

    %!---Denotar cada observacion --!%
    \begin{remark}
        Podemos ovservar que podemos agregar mas condiciones a la ejecución
        del algoritmo.
        En el modelo \textbf{asincrono}: Podemos decir que una ejecución es legal si cada
        proceso un numero infinito de eventos del tipo computacional,
        y ademas cualquiera que sean los eventos de comunicacion de algun canal de comunicación,
        este cambie de $MSG\in\Mu$ a $\delta$ en un tiempo finito.
        Lo anterior lo podemos pensar:Que estamos haciendo un mapeo 1-1 con cada $SENT(i,j,MSG)$
        con eventos del tipo $DELIVER(i,j,MSG)$.
    \end{remark}

    Tendremos por convención que un proceso $v_{i}$ despues de un evento del tipo
    $DELIVER(j,i,MSG)$ tendra un evento del tipo computacional.
    Para el modelo síncrono ademas de tener los requirimientos del modelo de computo
    asincrono se tendra como requerimiento que los procesos se ejecuten en pasos por
    bloqueo.Entonces diremos que una ejecución es legal en dicho modelo si ademas de los
    requerimientos del modelo asincrono, la condición es que los eventos computacionale
    ocurriran en \textbf{rondas}.
    Una de las condiciones de estas restricciones es que a cada proceso se le permite un evento
    del tipo computacional por cada ronda.
    Y ademas cada evento de computo en la ronda $r$ aparecera despues de los
    eventos de computo de la ronda $r-1$.
    Y ademas cada mensaje enviado en la ronda $r$ tendra que ser enviado antes de
    los eventos de computo de la ronda $r+1$.
    Vamos a dotar a este modelo de una diversidad de restricciones con ellos se daran tres tipos
    de modelos dependiendo la restriccion de el peso de los mensajes, de la ejecución de los
    eventos,por el momento nos vamos a centrar en las restricción de rondas en los eventos,y no vamos
    a poner restricción en el tamaño de los mensajes, a este modelo lo vamos a bautizar con el
    nombre de \textbf{LOCAL}.
    \newpage
    \subsection{Decidibilidad}\label{subsec:decidibilidad}
    Una vez que tenemos los elementos del modelo distribuido,podemos introducir la noción de \textbf{decibilidad}
    \theoremstyle{definition}
    \begin{definition}
        Sea una cadena $w =w_{1},\mathellipsis,w_{n}$ que esta alimentada en el algoritmo distribuido a saber
        $\Pi(w)$, donde de manera distribuida estamos dando inicialmente en la entrada de cada proceso $v_{j}$ con un pedazo
        de la cadena $w$ digamos $w_{k}$ que representa un pedazo de la cadena que es la entrada del proceso anunciado.
        Entonces decimos que el algoritmo distribuido acepta a la cadena $w$ si para toda ejecución del algoritmo
        existe un proceso $v_{t}$ tal que con su entrada local tiene un estado de aceptación.\\
        Formalmente:
        $\Pi$ \textbf{acepta} a $w$ si:
        \begin{equation}
           \forall \Kappa_{\Pi(G,w)} \ \exists v_{t} \ t\in\{1,\mathellipsis,m\} \
            tal \ que \ q_{t} = q_{accept}.
        \end{equation}
    \end{definition}
    %!--En otras palabras lo que quiere decir es lo siguiente --!%
    Donde acepta quiere decir que en algun momento de la ejecución del algoritmo,
    el correspondiete estado $q_{t}=q_{accept}$ que es la semantica de aceptación formalmente,
    denotaremos a las cadenas que son aceptadas por el modelo $LOCAL$ para un algoritmo arbitrario
    $\Pi$ como $L(\Pi)$
    %todo:Migrate the chapter to another file .tex e incluirlo en un main .tex
    \chapter{Simulación de modelos Maquina de Turing y \textbf{LOCAL}}\label{ch:simulacion-de-modelostextbfytextbf}
    \section{Noción de simulación en modelos}\label{sec:nocion-de-simulación-en-modelos}
    Una vez que tenemos estos dos modelos de computo formal, a nivel logico podemos decir que:
    \theoremstyle{definition}
    \begin{definition}
        Decimos que un modelo $T$ simula un modelo $S$ si:
        \begin{equation}
        \forall x\in L(S) \ entonces \ x\in L(T)
        \end{equation}
        Mas aún decimos que son modelos equivalentes (computacionalmente) si:
        \begin{equation}
        \forall x\in L(T) \iff x\in L(S) \
        \end{equation}
    \end{definition}
    \space
    Entonces enunciaremos nuestro teorema de la siguiente manera:

    \begin{theorem}
        Sea $TM$ una maquina de Turing, entonces existe un $\Pi$ algoritmo distribuido que simula
        a $TM$,con la semántica de \textbf{simulación} con base a la definición anterior.
    \end{theorem}
    Una vez esto nos podemos adentrar en el diseño de un algoritmo en el que burdamente le daremos en la entrada una
    rebanada de la cadena que es aceptada por una maquina de Turing en Abstracto y que es aceptada por dicho algoritmo.
    %the subsection of the algorithm as we can see

    \section{Diseño del algoritmo}\label{sec:diseño-del-algoritmo}
    \begin{remark}
        Trivialmente podemos pensar que al darle la entrada la cadena que es aceptada por una maquina de Turing,
        es consumida, tal que cada proceso la tiene enteramente como entrada, i.e $\Pi(w)$ entonces de manera local se da
        que $v_{j}(w)$ entonces esta en particular que en algun momento de la ejecucion el estado de ese proceso localmente,
        $q_{i}\gets q_{accept}$ entonces $w\in L(\Pi)$, pero podemos observar que la forma de la entrada en el algoritmo $\Pi$
        es de manera no distribuida.
    \end{remark}
    Entonces no es verdaderamente un diseño de un algoritmo distribuido,por lo tanto procederemos a diseñar de manera
    distribuida el siguiente algoritmo:
    \space
    %Una vez que tenemos esta información daremos una capa de adversario tal y como lo haremos de esta manera
    %En esta parte daremos una part externa que es la noción de rival en el siguiente sentido
    Daremos la distribución de la información a manera de contricante de la siguente manera:
    Sea $w\in L(TM)$ para una maquina de Turing $TM$ arbitraria, entonces decimos que una rebanada de la cadena
    $w[i]$ tiene localidad $i$.
    Esta semantica nos va a permitir definir lo siguiente:
    \theoremstyle{definition}
    \begin{definition}
        Sea un $v_{k}$ un proceso del modelo en particular $\text{LOCAL}$ diremos que dicho proceso
        tendra como entrada a una rebanada $w_{i}$ de la cadena $w$ denotada tambien como
        $w_{j}$, de localidad $j$
    \end{definition}
    En general podremos alimentar a cada proceso con una familia de rebanadas de cierta localidad.
    Esto nos da la noción del control externo de las entradas, que por el momento esto nos esta generando
    una cierta familiaridad del papel a un alto nivel de la visión del contrincante como podremos observar
    esta es la contraparte del algoritmo que esta gobernando computacionalmente (o por la capa de computo)
    por el algoritmo.
    \space
    Entonces nos propondremos el siguiente diseño del algoritmo que nos dara a priori
    la solución del problema que estamos atacando.

    %!---Esta es el diseño sin las definiciones anteriormente enunciadas --!%
    %!---Esto por la nocion del adversario que hemos enunciado anteriormente ---!%
    \begin{algorithm}
        \caption{$Simula\char95Algo\char95TM(w)$}\label{simula}
        \begin{algorithmic}
            \STATE $w_{1}\mathellipsis w_{k} \gets w$
            \STATE \textbf{Síncronamente}
               %!--Aqui estamos mapeando cada evento del tipo Comp con cada ronda ---!%
               \FORALL{$r=1$ \TO $n$}
                  \STATE $v_{j}(w_{i})$\COMMENT{Codigo para $v_{j}$}
                  \STATE $q_{j}\gets q_{0}$\COMMENT{Poner estando inicial en 0}
                  \WHILE{\textbf{true}}
                     \STATE \textbf{call} $\delta(q_{j},w_{i})$
                     \STATE $(q_{r},w_{r},P)\gets \delta(q_{j},w_{i})$
                  \ENDWHILE
                  \IF{$q_{r}=q_{accept}$}
                     \RETURN{$q_{r}$}
                  \ELSE
                     \STATE $\textbf{send}(t,MSG\gets<q_{r},w_{r},P>)$
                  \ENDIF
               \ENDFOR
        \end{algorithmic}
    \end{algorithm}
    \space
    %!--El siguiente capitulo es la descripción del algoritmom ----!%
    \section{Descripción del algoritmo}\label{sec:descripción-del-algoritmo}
    Entonces lo que podemos observar que en esencia estamos delegando con la función $\delta$
    que es parte de la información local del proceso $v_{j}$ pero tendremos un control en el que de manera implicita
    por la parte que esta teniendo la visión del contrincante,que es la naturaleza de la distribución de la información,
    en las entradas del buffer de cada $v_{j}\in V(G)$, donde la naturaleza topologica de $G$ es abstracta a priori.
    Pero la logica del token es que esta llamada sera iterada hasta que la rebanada de la cadena que nos da la invocacioń
    de $\delta$ sea una rebanada de localidad correspondiente al actual proceso que esta teniendo el evento $COMPUTE(j)$.
    Asi cuando esto sea falso, tendra una logica de aceptación o en su defecto de iniciar un evento del tipo de
    comunicación: $SEND(j,t,MSG)$ donde el $MSG$ es lo que nos arroja el ultimo llamado de $\delta$, donde $t$, denota
    sin perdida de generalidad el indice de uno de sus vecinos.
    \space
    Asi que enunciaremos los siguientes afirmaciones a manera de teorema del cual se desprendera la simulación de $TM$
    maquina de Turing via el modelo $LOCAL$.\newpage

    \section{Demostración del procedimiento $Simula\char95Algo\char95TM$}\label{sec:demostración-del-procedimiento}
    %!--Primera parte demostrativa del teorema --%!
    \begin{theorem}
        El algoritmo $Simula\char95Algo\char95TM$ es correcto.
    \end{theorem}
    \begin{proof}
        Sea $r$ una ronda de la ejecución del algoritmo $\Pi=Simula\char95Algo\char95TM$,
        al incio de esa ronda se estara iniciando un evento del tipo $COMPUTE(k)$, de nuestro repertorio de eventos para el proceso
        $v_{k}$, por la naturaleza de la distrubución de la información llegara un momento
        de la iteración en la que  se de una estructura de dato $msg\gets <q_{r},w_{r},P>$ arrojada por el llamado iterativo de
        $\delta$, ya que la localidad de $w_{r}$ no esta asignada a $v_{k}$ sin perdida de generalidad.
        Entonces siguiendo el codigo, observamos que tenemos una logica para la estructura de dato:
        si $q_{r}=q_{accept}$ entonces $w\in L(\Pi)$ y se acabaria la ejecución en dicha ronda.
        Si no, entonces se activa el evento $Send(t,MSG)$,donde sin perdida de generalidad $t$ representa el indice de uno de los vecinos
        del proceso $k$, por otro lado como $w\in L(TM)$ entonces $\exists v_{l}$ en la ronda $r+1$
        tal que al final dicha ronda $\exists q_{l}$ estado tal que $q_{l} = q_{accept}$.\newline
        $\therefore w\in L(\pi)$, por lo tanto el algoritmo es correcto.

    \end{proof}
    Una vez que tenemos la corrección del algoritmo se desprende a manera de corolario la
    simulación de $TM$ en $LOCAL$.
    \begin{corrollary}
        Sea $TM$ una maquina de Turing, entonces:
        \begin{equation}
            \forall w \  \in L(TM) \ \exists \Pi \ algoritmo \ en \ LOCAL\ t.q \ w \ \in L(\Pi)
        \end{equation}
    \end{corrollary}

    \begin{proof}
        Sean $w\in L(TM)$ para una maquina de Turing y  $\Pi =Simula\char95Algo\char95TM$, $\Pi(w)$ como dicho algoritmo es correcto por el teorema 2,
        entonces ya tenemos un algoritmo  en $LOCAL$ que hace  que $w\in L(w) \ \forall w\in L(TM)$,
        que semanticamente se reduce a que $\Pi$ \textbf{simula} a $TM$ con $TM$ en abstracto.
    \end{proof}
    %!---Lo que falta es hacer un analisis de complejidad del algoritmo a manera de seccion ---!%

    Entonces una vez que tenemos un algoritmo que es correcto a nivel semantico,
    la siguiente pregunta es la complejidad asociada a la ejecución de $\Pi \gets Simula\char95Algo\char95TM$
    tanto espacial,de comunicación asi como temporal.
    %!---Todo: lo que tenemos que hacer ahora es hacer es una revisión ortograica del doc---!%
    \subsection{Complejidad del algoritmo}\label{subsec:complejidad-del-algoritmo}
    %todo:hacer un main.tex para hacer parte de esta estructura extendible hasta el final de la misma






\end{document}